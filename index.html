import React, {useRef, useState, useEffect} from 'react';

/**
 * ResponsiveVideoPlayer.jsx
 * Default-exported React component (single-file) that attempts to play a video from a provided URL.
 * - If the URL points to a direct video file (mp4, webm, ogg), it uses a native <video> element with rich controls.
 * - Otherwise it falls back to an iframe embed (Facebook/YouTube/etc) using a best-effort embed URL.
 * - Supports optional JSON config (pass configUrl) to supply settings like poster, autoplay, muted, loop.
 * - Exposes methods: play/pause, toggleMute, enterFullscreen, requestPIP.
 *
 * Usage example:
 * <ResponsiveVideoPlayer
 *    videoUrl="https://example.com/video.mp4"
 *    poster="/images/thumb.jpg"
 *    captionsUrl="/subs/en.vtt"
 *    configUrl="/player-config.json"
 *    className="max-w-3xl mx-auto"
 * />
 *
 * Notes:
 * - Facebook video "share" pages are not direct mp4 links. The component will try to embed using
 *   the Facebook Video plugin (iframe) if the URL is not a direct file.
 * - If you want every video source to be treated as a direct stream, provide a direct file link or HLS manifest.
 */

// Utility helpers
const isDirectVideoFile = (url) => {
  if (!url || typeof url !== 'string') return false;
  return /\.(mp4|webm|ogg|mov|m4v)(\?.*)?$/i.test(url) || /\.m3u8(\?.*)?$/i.test(url);
};

const makeFacebookEmbed = (url, width = 560) => {
  const href = encodeURIComponent(url);
  return `https://www.facebook.com/plugins/video.php?href=${href}&show_text=0&width=${width}`;
};

export default function ResponsiveVideoPlayer({
  videoUrl,
  poster = '',
  captionsUrl = '',
  configUrl = '',
  className = '',
  preload = 'metadata',
  controls = true,
}) {
  const videoRef = useRef(null);
  const containerRef = useRef(null);
  const [isDirect, setIsDirect] = useState(false);
  const [isPlaying, setIsPlaying] = useState(false);
  const [muted, setMuted] = useState(false);
  const [autoplay, setAutoplay] = useState(false);
  const [loop, setLoop] = useState(false);
  const [fetchedConfig, setFetchedConfig] = useState(null);

  useEffect(() => {
    setIsDirect(isDirectVideoFile(videoUrl));
  }, [videoUrl]);

  // Optionally fetch a JSON config at runtime (e.g. from a JSON file you host)
  useEffect(() => {
    let mounted = true;
    if (!configUrl) return;
    fetch(configUrl)
      .then((r) => r.json())
      .then((json) => {
        if (!mounted) return;
        setFetchedConfig(json);
        if (json.autoplay) setAutoplay(Boolean(json.autoplay));
        if (json.loop) setLoop(Boolean(json.loop));
        if (typeof json.muted !== 'undefined') setMuted(Boolean(json.muted));
      })
      .catch(() => {
        // ignore errors silently — config is optional
      });
    return () => (mounted = false);
  }, [configUrl]);

  // Playback state synchronization
  useEffect(() => {
    const v = videoRef.current;
    if (!v) return;
    const onPlay = () => setIsPlaying(true);
    const onPause = () => setIsPlaying(false);
    v.addEventListener('play', onPlay);
    v.addEventListener('pause', onPause);
    return () => {
      v.removeEventListener('play', onPlay);
      v.removeEventListener('pause', onPause);
    };
  }, []);

  // Controls API
  const togglePlay = async () => {
    const v = videoRef.current;
    if (!v) return;
    try {
      if (v.paused) await v.play();
      else v.pause();
    } catch (e) {
      // autoplay policy might block play — ignore
    }
  };

  const toggleMute = () => {
    const v = videoRef.current;
    if (!v) return;
    v.muted = !v.muted;
    setMuted(v.muted);
  };

  const enterFullscreen = async () => {
    const el = containerRef.current;
    if (!el) return;
    if (el.requestFullscreen) await el.requestFullscreen();
    else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
    else if (el.msRequestFullscreen) el.msRequestFullscreen();
  };

  const requestPIP = async () => {
    const v = videoRef.current;
    if (!v) return;
    if (document.pictureInPictureEnabled && !v.disablePictureInPicture) {
      try {
        if (v !== document.pictureInPictureElement) await v.requestPictureInPicture();
        else await document.exitPictureInPicture();
      } catch (e) {
        // ignore
      }
    }
  };

  // Build embed fallback (iframe) — best-effort for Facebook, YouTube and generic.
  const getIframeSrc = (url) => {
    if (!url) return '';
    try {
      const host = new URL(url).hostname.toLowerCase();
      if (host.includes('facebook.com')) return makeFacebookEmbed(url, 560);
      if (host.includes('youtube.com') || host.includes('youtu.be')) {
        // allow YouTube watch URL or short url — convert to embed
        // extract video id
        const idMatch = url.match(/(v=|\/)([A-Za-z0-9_-]{6,})/);
        const vid = idMatch ? idMatch[2] : null;
        if (vid) return `https://www.youtube.com/embed/${vid}`;
      }
      // generic fallback: just load the page in an iframe (may be blocked by X-Frame-Options)
      return url;
    } catch (e) {
      return url;
    }
  };

  return (
    <div ref={containerRef} className={`video-player-root ${className}`}> 
      <div className="relative bg-black rounded-2xl overflow-hidden shadow-lg">
        {/* Native player when direct file */}
        {isDirect ? (
          <div className="w-full aspect-video bg-black relative">
            <video
              ref={videoRef}
              src={videoUrl}
              poster={poster || (fetchedConfig && fetchedConfig.poster) || ''}
              preload={preload}
              controls={controls}
              autoPlay={autoplay}
              muted={muted}
              loop={loop}
              className="w-full h-full object-contain"
            >
              {captionsUrl && (
                <track src={captionsUrl} kind="subtitles" srcLang="en" label="English" default />
              )}
              Sorry — your browser does not support the video element.
            </video>

            {/* custom minimal control bar (overlay) */}
            <div className="absolute left-3 bottom-3 flex items-center gap-3">
              <button
                onClick={togglePlay}
                className="px-3 py-1 rounded-md bg-black/40 backdrop-blur text-sm"
                aria-label="Play / Pause"
              >
                {isPlaying ? 'Pause' : 'Play'}
              </button>
              <button
                onClick={toggleMute}
                className="px-3 py-1 rounded-md bg-black/40 text-sm"
                aria-label="Mute toggle"
              >
                {muted ? 'Unmute' : 'Mute'}
              </button>
              <button
                onClick={requestPIP}
                className="px-3 py-1 rounded-md bg-black/40 text-sm"
                aria-label="Picture-in-Picture"
              >
                PIP
              </button>
              <button
                onClick={enterFullscreen}
                className="px-3 py-1 rounded-md bg-black/40 text-sm"
                aria-label="Fullscreen"
              >
                Full
              </button>
            </div>
          </div>
        ) : (
          // Fallback to iframe embed
          <div className="w-full aspect-video bg-black flex items-center justify-center">
            <iframe
              title="embedded-video"
              src={getIframeSrc(videoUrl)}
              allow="autoplay; encrypted-media; picture-in-picture"
              allowFullScreen
              className="w-full h-full"
            />
          </div>
        )}
      </div>

      {/* small meta area */}
      <div className="mt-3 flex items-center justify-between text-sm text-slate-500">
        <div>Source: <span className="text-slate-700">{videoUrl}</span></div>
        <div className="flex items-center gap-2">
          {configUrl && <div className="px-2 py-1 rounded bg-slate-100 text-xs">Config: {configUrl}</div>}
          <div className="px-2 py-1 rounded bg-slate-100 text-xs">Direct file: {isDirect ? 'yes' : 'no'}</div>
        </div>
      </div>

    </div>
  );
}
